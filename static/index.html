<!DOCTYPE html>
<html lang="ru">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>–ö–∞–ª—å–∫—É–ª—è—Ç–æ—Ä-–∏–Ω—Ç–µ—Ä–ø—Ä–µ—Ç–∞—Ç–æ—Ä</title>
  <style>
:root{
  --bg: #1b1c21;
  --card: rgba(28,29,34,0.88);
  --muted: #a0a3b0;
  --accent: #5b7cff;
  --success: #1f8f4b;
  --danger: #d4494a;
  --glass: rgba(28,29,34,0.5);
  --neon: rgba(91,124,255,0.18);
  --radius: 16px;
  --mono: ui-monospace, SFMono-Regular, Menlo, Monaco, "Roboto Mono", "Courier New", monospace;
  --scale: 1.35;
}

*{box-sizing:border-box}
html,body{height:100%}
body{
  margin:0;
  font-family: Inter, ui-sans-serif, system-ui, -apple-system, "Segoe UI", Roboto, "Helvetica Neue", Arial;
  background: linear-gradient(180deg,var(--bg),#121217 70%);
  color:#eee;
  font-size:calc(14px * var(--scale));
  -webkit-font-smoothing:antialiased;
  -moz-osx-font-smoothing:grayscale;
  padding:36px;
  display:flex;
  align-items:center;
  justify-content:center;
}

.app{
  width:1242px; max-width:96vw; min-height:730px;
  border-radius:24px;
  background: linear-gradient(180deg, rgba(28,29,34,0.9), rgba(31,32,37,0.95));
  box-shadow: 0 10px 40px rgba(0,0,0,0.3), inset 0 1px 0 rgba(255,255,255,0.03);
  padding:28px;
  position:relative;
  overflow:hidden;
  border: 1px solid rgba(255,255,255,0.05);
}

.topbar{
  display:flex;
  align-items:center;
  justify-content:space-between;
  gap:20px;
  margin-bottom:20px;
}
.title{
  margin:0;
  font-size:calc(18px * var(--scale));
  letter-spacing:0.2px;
  font-weight:600;
  color:#fff;
}
.controls{display:flex;gap:12px;align-items:center}

.pill{
  background:transparent;
  border:1px solid rgba(255,255,255,0.1);
  padding:10px 16px;
  border-radius:999px;
  font-size:calc(13px * var(--scale));
  cursor:pointer;
  transition:transform .18s cubic-bezier(.2,.9,.2,1), box-shadow .18s;
  box-shadow: 0 2px 14px rgba(0,0,0,0.15);
  color:#eee;
}
.pill:hover{transform:translateY(-2px)}
.pill:active{transform:translateY(0)}
.btn-ghost{background:transparent}

.panel{padding:18px;background:transparent;border-radius:16px}

.output{
  min-height:380px; max-height:500px;
  overflow:auto;
  border-radius:16px;
  padding:24px;
  font-family: var(--mono);
  font-size:calc(13px * var(--scale));
  line-height:1.6;
  background: linear-gradient(180deg, rgba(28,29,34,0.6), rgba(31,32,37,0.6));
  border:1px solid rgba(255,255,255,0.05);
  box-shadow: 0 10px 30px rgba(0,0,0,0.15);
  position:relative;
}

.output:focus-within, .prompt input:focus{
  box-shadow: 0 8px 40px var(--neon);
  outline: none;
  border-color: rgba(91,124,255,0.4);
}

.prompt{
  margin-top:20px;
  display:grid;
  grid-template-columns:100px 1fr 160px;
  gap:16px;
  align-items:center;
}
.prompt-left{display:flex;align-items:center}
.prompt-label{
  font-family:var(--mono);
  color:var(--muted);
  background: linear-gradient(180deg,#212128,#27272d);
  padding:10px 14px;
  border-radius:12px;
  border:1px solid rgba(255,255,255,0.06);
  box-shadow: 0 3px 16px rgba(0,0,0,0.1), inset 0 -1px 0 rgba(255,255,255,0.02);
}

.prompt-center input{
  width:100%;
  padding:14px 16px;
  border-radius:16px;
  border:1px solid rgba(255,255,255,0.06);
  background: linear-gradient(180deg, #1c1d22,#1f2027);
  font-family:var(--mono);
  font-size:calc(14px * var(--scale));
  caret-color: var(--accent);
  box-shadow: 0 6px 24px rgba(0,0,0,0.1);
  transition: box-shadow .15s;
  color: #e0e0e0;
}
.prompt-center input::placeholder{color:#7a7c87; font-family:var(--mono)}

.cursor {
  display:inline-block;
  width:10px;
  height:20px;
  background:linear-gradient(90deg, rgba(91,124,255,0.9), rgba(91,124,255,0.6));
  margin-left:6px;
  vertical-align:middle;
  animation: blink 1s steps(2,end) infinite;
}
@keyframes blink { 50% { opacity:0 } }

.btn-warp{
  --depth: 18px;
  position:relative;
  padding:14px 20px;
  border-radius:16px;
  font-weight:600;
  border: none;
  background: linear-gradient(180deg,#2b2c34,#24242b);
  box-shadow:
    0 calc(var(--depth) * 0.06) calc(var(--depth) * 0.6) rgba(0,0,0,0.25),
    0 3px 8px rgba(91,124,255,0.15),
    inset 0 -1px 0 rgba(255,255,255,0.02);
  transform-style:preserve-3d;
  transition: transform .18s cubic-bezier(.2,.9,.2,1), box-shadow .18s;
  cursor:pointer;
  color:#eee;
}
.btn-warp:hover{ transform: translateY(-4px) rotateX(2deg) scale(1.01); }
.btn-warp:active{ transform: translateY(-1px) rotateX(0); box-shadow: 0 2px 8px rgba(0,0,0,0.15); }

.cards{
  position:absolute;
  top:28px;
  right:28px;
  width:480px;
  max-height:82%;
  border-radius:16px;
  background:var(--card);
  box-shadow: 0 20px 60px rgba(0,0,0,0.3);
  border:1px solid rgba(255,255,255,0.06);
  overflow:auto;
  padding:16px;
  transition:transform .22s cubic-bezier(.2,.9,.2,1),opacity .22s;
  transform-origin:top right;
}
.cards.hidden{ transform: translateY(-14px) scale(0.98); opacity:0; pointer-events:none; }
.cards-inner{ display:flex; flex-direction:column; gap:12px; padding-bottom:12px; }
.card{
  padding:14px;
  border-radius:12px;
  background:linear-gradient(180deg,rgba(40,41,48,0.95), rgba(35,36,44,0.95));
  border:1px solid rgba(255,255,255,0.05);
  box-shadow: 0 8px 22px rgba(0,0,0,0.18);
  cursor:pointer;
  transition:transform .12s;
}
.card:hover{ transform:translateY(-6px); box-shadow: 0 18px 36px rgba(0,0,0,0.28) }
.card .meta{ font-size:calc(12px * var(--scale)); color:var(--muted); margin-bottom:6px; font-family:var(--mono) }
.card .body{ font-weight:600; font-size:calc(14px * var(--scale)); color:#eee }

.line {
  opacity:0;
  transform: translateY(6px);
  animation: lineEnter .36s cubic-bezier(.2,.9,.2,1) forwards;
}
@keyframes lineEnter {
  to { opacity:1; transform: translateY(0); }
}
.result { color:var(--success); font-weight:600; }
.error  { color:var(--danger); font-weight:700; }

.output::-webkit-scrollbar { width: 8px; }
.output::-webkit-scrollbar-track { background: rgba(28,29,34,0.2); border-radius: 8px; }
.output::-webkit-scrollbar-thumb { background-color: rgba(91,124,255,0.5); border-radius: 8px; border: 2px solid rgba(28,29,34,0.2); }
.output::-webkit-scrollbar-thumb:hover { background-color: rgba(91,124,255,0.8); }

/* WebRTC Video Modal */
.webrtc-modal {
  position: fixed;
  top: 80px;
  right: 24px;
  width: 420px;
  background: linear-gradient(180deg, rgba(28,29,34,0.98), rgba(31,32,37,0.98));
  border-radius: 20px;
  box-shadow: 0 20px 80px rgba(0,0,0,0.6);
  border: 1px solid rgba(255,255,255,0.08);
  backdrop-filter: blur(40px);
  z-index: 1000;
  display: none;
}

.webrtc-modal.active {
  display: block;
  animation: modalEnter 0.4s cubic-bezier(0.2, 0.9, 0.2, 1);
}

@keyframes modalEnter {
  from {
    opacity: 0;
    transform: translateX(100px) scale(0.95);
  }
  to {
    opacity: 1;
    transform: translateX(0) scale(1);
  }
}

.modal-header {
  padding: 20px 24px;
  border-bottom: 1px solid rgba(255,255,255,0.05);
  display: flex;
  align-items: center;
  justify-content: space-between;
  cursor: move;
  user-select: none;
}

.modal-title {
  font-size: 16px;
  font-weight: 600;
  color: #fff;
  display: flex;
  align-items: center;
  gap: 10px;
}

.call-timer {
  font-size: 14px;
  color: var(--accent);
  font-family: var(--mono);
  margin-left: auto;
}

.status-indicator {
  width: 8px;
  height: 8px;
  border-radius: 50%;
  background: var(--success);
  animation: pulse 2s infinite;
}

@keyframes pulse {
  0%, 100% { opacity: 1; }
  50% { opacity: 0.4; }
}

.modal-close {
  background: transparent;
  border: none;
  color: var(--muted);
  font-size: 24px;
  cursor: pointer;
  padding: 0;
  width: 32px;
  height: 32px;
  display: flex;
  align-items: center;
  justify-content: center;
  border-radius: 8px;
  transition: all 0.2s;
}

.modal-close:hover {
  background: rgba(255,255,255,0.05);
  color: #fff;
}

.modal-body {
  padding: 24px;
}

.video-container {
  position: relative;
  margin-bottom: 20px;
}

.video-container.audio-only {
  display: none;
}

.audio-call-indicator {
  text-align: center;
  padding: 40px 20px;
  background: rgba(0,0,0,0.2);
  border-radius: 12px;
  margin-bottom: 20px;
}

.audio-call-indicator .icon {
  font-size: 48px;
  margin-bottom: 16px;
}

.audio-call-indicator .text {
  font-size: 16px;
  color: var(--accent);
  font-weight: 600;
}

.video-wrapper {
  position: relative;
  background: rgba(0,0,0,0.4);
  border-radius: 12px;
  overflow: hidden;
  aspect-ratio: 16/9;
  border: 1px solid rgba(255,255,255,0.06);
  margin-bottom: 12px;
}

.video-wrapper video {
  width: 100%;
  height: 100%;
  object-fit: cover;
}

.video-label {
  position: absolute;
  top: 12px;
  left: 12px;
  background: rgba(0,0,0,0.7);
  padding: 6px 12px;
  border-radius: 6px;
  font-size: 11px;
  text-transform: uppercase;
  letter-spacing: 0.5px;
  color: var(--accent);
}

.call-controls {
  display: flex;
  gap: 12px;
  justify-content: center;
}

.call-btn {
  padding: 12px 24px;
  border: none;
  border-radius: 10px;
  font-size: 14px;
  font-weight: 600;
  cursor: pointer;
  transition: all 0.2s;
  display: flex;
  align-items: center;
  gap: 8px;
}

.call-btn-accept {
  background: var(--success);
  color: white;
}

.call-btn-decline {
  background: var(--danger);
  color: white;
}

.call-btn-end {
  background: var(--danger);
  color: white;
}

.call-btn:hover {
  transform: translateY(-2px);
  box-shadow: 0 6px 20px rgba(0,0,0,0.3);
}

/* Notification System */
.notification-container {
  position: fixed;
  top: 24px;
  right: 24px;
  z-index: 2000;
  display: flex;
  flex-direction: column;
  gap: 12px;
  pointer-events: none;
}

.notification {
  background: linear-gradient(135deg, rgba(28,29,34,0.98), rgba(31,32,37,0.98));
  border-radius: 12px;
  padding: 16px 20px;
  box-shadow: 0 12px 40px rgba(0,0,0,0.5);
  border: 1px solid rgba(255,255,255,0.08);
  backdrop-filter: blur(20px);
  display: flex;
  align-items: center;
  gap: 12px;
  min-width: 320px;
  pointer-events: all;
  animation: notificationEnter 0.4s cubic-bezier(0.2, 0.9, 0.2, 1);
}

@keyframes notificationEnter {
  from {
    opacity: 0;
    transform: translateX(100px);
  }
  to {
    opacity: 1;
    transform: translateX(0);
  }
}

.notification.exit {
  animation: notificationExit 0.3s cubic-bezier(0.2, 0.9, 0.2, 1) forwards;
}

@keyframes notificationExit {
  to {
    opacity: 0;
    transform: translateX(100px);
  }
}

.notification-icon {
  font-size: 24px;
  flex-shrink: 0;
}

.notification-content {
  flex: 1;
}

.notification-title {
  font-weight: 600;
  font-size: 14px;
  margin-bottom: 4px;
}

.notification-message {
  font-size: 12px;
  color: var(--muted);
}

.notification.success .notification-icon {
  color: var(--success);
}

.notification.info .notification-icon {
  color: var(--accent);
}

.notification.incoming-call {
  background: linear-gradient(135deg, rgba(91,124,255,0.15), rgba(28,29,34,0.98));
  border-color: var(--accent);
  animation: notificationEnter 0.4s cubic-bezier(0.2, 0.9, 0.2, 1), callPulse 2s infinite;
}

@keyframes callPulse {
  0%, 100% { box-shadow: 0 12px 40px rgba(91,124,255,0.3); }
  50% { box-shadow: 0 12px 60px rgba(91,124,255,0.6); }
}

.incoming-call-info {
  margin-top: 8px;
  padding-top: 8px;
  border-top: 1px solid rgba(255,255,255,0.1);
}

.incoming-call-from {
  font-size: 13px;
  color: var(--accent);
  font-weight: 600;
  margin-bottom: 8px;
}

.incoming-call-buttons {
  display: flex;
  gap: 8px;
}

.incoming-call-btn {
  flex: 1;
  padding: 8px 12px;
  border: none;
  border-radius: 8px;
  font-size: 12px;
  font-weight: 600;
  cursor: pointer;
  transition: all 0.2s;
}

.incoming-call-btn.accept {
  background: var(--success);
  color: white;
}

.incoming-call-btn.decline {
  background: rgba(255,255,255,0.1);
  color: #fff;
}

.incoming-call-btn:hover {
  transform: translateY(-2px);
}

@media (max-width:1024px){
  .app{ width:96vw; padding:20px }
  .prompt{ grid-template-columns:80px 1fr 120px }
  .cards{ width:92vw; left:4vw; right:4vw; top:20px }
  .webrtc-modal { 
    width: 90vw; 
    right: 5vw !important;
    left: auto !important;
  }
}
  </style>
</head>
<body>
  <main class="app">
    <header class="topbar">
      <h1 class="title">–ö–∞–ª—å–∫—É–ª—è—Ç–æ—Ä-–∏–Ω—Ç–µ—Ä–ø—Ä–µ—Ç–∞—Ç–æ—Ä</h1>
      <div class="controls">
        <button class="pill btn-ghost" id="btn-vars">–ü–µ—Ä–µ–º–µ–Ω–Ω—ã–µ</button>
        <button class="pill btn-ghost" id="btn-history">–ò—Å—Ç–æ—Ä–∏—è</button>
        <button class="pill btn-ghost" id="btn-clear">–û—á–∏—Å—Ç–∏—Ç—å</button>
      </div>
    </header>

    <section class="panel">
      <div id="output" class="output" aria-live="polite">
        –î–æ–±—Ä–æ –ø–æ–∂–∞–ª–æ–≤–∞—Ç—å. –í–≤–µ–¥–∏—Ç–µ –∫–æ–º–∞–Ω–¥—É.<br>
        <small style="color: #8a8d98; margin-top: 8px; display: block;">
          üí° –ö–æ–º–∞–Ω–¥—ã WebRTC:<br>
          ‚Ä¢ <code>login –∏–º—è</code> –∏–ª–∏ <code>–≤–æ–π—Ç–∏ –∏–º—è</code> - –∞–≤—Ç–æ—Ä–∏–∑–∞—Ü–∏—è<br>
          ‚Ä¢ <code>–ø–æ–∑–≤–æ–Ω–∏—Ç—å –∏–º—è video/audio</code> - –≤–∏–¥–µ–æ/–∞—É–¥–∏–æ –∑–≤–æ–Ω–æ–∫<br>
          ‚Ä¢ <code>call –∏–º—è video/audio</code> - –∞–ª—å—Ç–µ—Ä–Ω–∞—Ç–∏–≤–∞
        </small>
      </div>

      <form id="promptForm" class="prompt" autocomplete="off">
        <div class="prompt-left">
          <span class="prompt-label">calc&gt;</span>
        </div>
        <div class="prompt-center">
          <input id="input" name="input" type="text" spellcheck="false" placeholder="–í–≤–µ–¥–∏—Ç–µ –∫–æ–º–∞–Ω–¥—É..." />
        </div>
        <div class="prompt-right">
          <button type="submit" class="btn-warp" id="btn-send">–í—ã–ø–æ–ª–Ω–∏—Ç—å</button>
        </div>
      </form>
    </section>

    <aside id="cards" class="cards hidden" aria-hidden="true">
      <div class="cards-inner" id="cards-inner"></div>
      <div class="cards-footer">
        <button class="pill" id="close-cards">–ó–∞–∫—Ä—ã—Ç—å</button>
      </div>
    </aside>
  </main>

  <!-- WebRTC Video Modal -->
  <div class="webrtc-modal" id="webrtcModal">
    <div class="modal-header" id="modalHeader">
      <div class="modal-title">
        <span class="status-indicator" id="statusIndicator"></span>
        <span id="modalTitleText">–ó–≤–æ–Ω–æ–∫</span>
        <span class="call-timer" id="callTimer">00:00</span>
      </div>
      <button class="modal-close" onclick="closeVideoModal()">√ó</button>
    </div>
    <div class="modal-body">
      <div class="audio-call-indicator" id="audioCallIndicator" style="display:none;">
        <div class="icon">üé§</div>
        <div class="text">–ê—É–¥–∏–æ–∑–≤–æ–Ω–æ–∫</div>
      </div>
      <div class="video-container" id="videoContainer">
        <div class="video-wrapper">
          <video id="localVideo" autoplay muted playsinline></video>
          <div class="video-label">–í—ã</div>
        </div>
        <div class="video-wrapper">
          <video id="remoteVideo" autoplay playsinline></video>
          <div class="video-label">–°–æ–±–µ—Å–µ–¥–Ω–∏–∫</div>
        </div>
      </div>
      <div class="call-controls" id="callControls">
        <button class="call-btn call-btn-end" onclick="endCall()">
          üìµ –ó–∞–≤–µ—Ä—à–∏—Ç—å –∑–≤–æ–Ω–æ–∫
        </button>
      </div>
    </div>
  </div>

  <!-- Notification Container -->
  <div class="notification-container" id="notificationContainer"></div>

  <script>
    // API: /api/execute, /api/vars, /api/history
    const output = document.getElementById('output');
    const input = document.getElementById('input');
    const form = document.getElementById('promptForm');
    const btnVars = document.getElementById('btn-vars');
    const btnHistory = document.getElementById('btn-history');
    const btnClear = document.getElementById('btn-clear');
    const cards = document.getElementById('cards');
    const cardsInner = document.getElementById('cards-inner');
    const closeCards = document.getElementById('close-cards');

    // WebRTC Variables
    const serverUrl = 'wss://webrtc-go-server-production.up.railway.app/ws';
    let username = null;
    let ws = null;
    let peerConnection = null;
    let localStream = null;
    let remoteUser = null;
    let currentCallType = null;
    let isInitiator = false;
    let pendingOffer = null;
    let pendingCandidates = [];
    let currentNotificationId = null;
    let callStartTime = null;
    let callTimerInterval = null;

    const iceServers = {
      iceServers: [
        { urls: 'stun:stun.l.google.com:19302' },
        { urls: 'stun:stun1.l.google.com:19302' }
      ]
    };

    let lineIndex = 0;

    const AudioCtx = window.AudioContext || window.webkitAudioContext;
    const audioCtx = AudioCtx ? new AudioCtx() : null;
    
    function beep(type='success'){
      if(!audioCtx) return;
      const o = audioCtx.createOscillator();
      const g = audioCtx.createGain();
      o.type = 'sine';
      o.frequency.value = type==='success'?880:220;
      g.gain.value = 0.0001;
      o.connect(g);
      g.connect(audioCtx.destination);
      const now = audioCtx.currentTime;
      g.gain.setValueAtTime(0.0001, now);
      g.gain.exponentialRampToValueAtTime(0.06, now + 0.01);
      o.start(now);
      g.gain.exponentialRampToValueAtTime(0.0001, now + 0.18);
      o.stop(now + 0.2);
    }

    function esc(s){
      if(typeof s!=='string') s=JSON.stringify(s);
      return s.replace(/[&<>"']/g,(m)=>({'&':'&amp;','<':'&lt;','>':'&gt;','"':'&quot;',"'":'&#39;'})[m])
    }

    function appendLine(text,{type='plain',typing=false}={}){
      lineIndex++;
      const wrapper=document.createElement('div');
      wrapper.className='line';
      wrapper.style.animationDelay=`${lineIndex*40}ms`;

      const pre=document.createElement('span');
      pre.className='line-pre';
      pre.style.color='var(--muted)';
      pre.style.marginRight='8px';
      pre.style.fontFamily='var(--mono)';
      pre.textContent='';

      const content=document.createElement('span');
      content.className=(type==='result')?'result':(type==='error'?'error':'');
      content.style.whiteSpace='pre-wrap';
      content.style.fontFamily='var(--mono)';
      content.innerHTML='';

      wrapper.appendChild(pre);
      wrapper.appendChild(content);
      output.appendChild(wrapper);
      output.scrollTop=output.scrollHeight;

      if(typing){
        const txt=typeof text==='string'?text:JSON.stringify(text,null,2);
        let i=0;
        const speed=10;
        const cursor=document.createElement('span');
        cursor.className='cursor';
        pre.appendChild(cursor);
        function step(){
          if(i<=txt.length){
            content.innerHTML=esc(txt.slice(0,i));
            output.scrollTop=output.scrollHeight;
            i++;
            setTimeout(step,speed);
          } else pre.removeChild(cursor);
        }
        step();
      } else {
        content.innerHTML=esc(typeof text==='string'?text:JSON.stringify(text,null,2));
      }
    }

    function clearOutput(){lineIndex=0;output.innerHTML='';}

    // Notification System
    function showNotification(title, message, type = 'info', duration = 4000) {
      const container = document.getElementById('notificationContainer');
      const notification = document.createElement('div');
      notification.className = `notification ${type}`;
      
      const icons = {
        success: '‚úÖ',
        error: '‚ùå',
        info: '‚ÑπÔ∏è',
        'incoming-call': 'üìû'
      };

      notification.innerHTML = `
        <div class="notification-icon">${icons[type] || 'üì¢'}</div>
        <div class="notification-content">
          <div class="notification-title">${title}</div>
          <div class="notification-message">${message}</div>
        </div>
      `;

      container.appendChild(notification);

      if (duration > 0) {
        setTimeout(() => {
          notification.classList.add('exit');
          setTimeout(() => notification.remove(), 300);
        }, duration);
      }

      return notification;
    }

    // Call Timer Functions
    function startCallTimer() {
      callStartTime = Date.now();
      updateCallTimer();
      callTimerInterval = setInterval(updateCallTimer, 1000);
    }

    function updateCallTimer() {
      if (!callStartTime) return;
      const elapsed = Math.floor((Date.now() - callStartTime) / 1000);
      const minutes = Math.floor(elapsed / 60);
      const seconds = elapsed % 60;
      const timerEl = document.getElementById('callTimer');
      if (timerEl) {
        timerEl.textContent = `${String(minutes).padStart(2, '0')}:${String(seconds).padStart(2, '0')}`;
      }
    }

    function stopCallTimer() {
      if (callTimerInterval) {
        clearInterval(callTimerInterval);
        callTimerInterval = null;
      }
      callStartTime = null;
      const timerEl = document.getElementById('callTimer');
      if (timerEl) {
        timerEl.textContent = '00:00';
      }
    }

    function showIncomingCallNotification(callerName, sessionType) {
      const container = document.getElementById('notificationContainer');
      const notification = document.createElement('div');
      notification.className = 'notification incoming-call';
      
      notification.innerHTML = `
        <div class="notification-icon">üìû</div>
        <div class="notification-content">
          <div class="notification-title">–í—Ö–æ–¥—è—â–∏–π ${sessionType === 'video' ? '–≤–∏–¥–µ–æ' : '–∞—É–¥–∏–æ'}–∑–≤–æ–Ω–æ–∫</div>
          <div class="incoming-call-info">
            <div class="incoming-call-from">–û—Ç: ${callerName}</div>
            <div class="incoming-call-buttons">
              <button class="incoming-call-btn accept" onclick="acceptCallFromNotification()">‚úÖ –ü—Ä–∏–Ω—è—Ç—å</button>
              <button class="incoming-call-btn decline" onclick="declineCallFromNotification()">‚ùå –û—Ç–∫–ª–æ–Ω–∏—Ç—å</button>
            </div>
          </div>
        </div>
      `;

      container.appendChild(notification);
      currentNotificationId = notification;
      beep('error'); // Ring sound

      return notification;
    }

    // WebRTC Functions
    async function webrtcLogin(name) {
      
      username = name;

      if (username && ws && ws.readyState === WebSocket.OPEN) {
        appendLine('‚ùå –£–∂–µ –≤—ã–ø–æ–ª–Ω–µ–Ω –≤—Ö–æ–¥.');
        return;
      }
      try {
        ws = new WebSocket(serverUrl);
        
        ws.onopen = () => {
          ws.send(JSON.stringify({
            type: 'login',
            username: username
          }));
        };

        ws.onmessage = handleWebSocketMessage;
        
        ws.onerror = () => {
          appendLine('‚ùå –û—à–∏–±–∫–∞ WebSocket', {type: 'error', typing: true});
        };
        
        ws.onclose = () => {
          appendLine('üîå WebSocket –æ—Ç–∫–ª—é—á–µ–Ω', {type: 'plain'});
          username = null;
        };
        
      } catch (error) {
        appendLine(`‚ùå –û—à–∏–±–∫–∞ –∞–≤—Ç–æ—Ä–∏–∑–∞—Ü–∏–∏: ${error.message}`, {type: 'error', typing: true});
        beep('error');
      }
    }

    async function handleWebSocketMessage(event) {
      const data = JSON.parse(event.data);
      
      switch(data.type) {
        case 'login_success':
          appendLine(`‚úÖ –ê–≤—Ç–æ—Ä–∏–∑–∞—Ü–∏—è —É—Å–ø–µ—à–Ω–∞: ${data.username}`, {type: 'result', typing: true});
          showNotification('–£—Å–ø–µ—à–Ω–æ!', `–í—ã –≤–æ—à–ª–∏ –∫–∞–∫ ${data.username}`, 'success');
          beep('success');
          break;
          
        case 'incoming_call':
          appendLine(`üìû –í—Ö–æ–¥—è—â–∏–π ${data.callType} –∑–≤–æ–Ω–æ–∫ –æ—Ç ${data.from}`, {type: 'plain', typing: true});
          remoteUser = data.from;
          currentCallType = data.callType;
          isInitiator = false;
          pendingOffer = null;
          pendingCandidates = [];
          showIncomingCallNotification(data.from, data.callType);
          break;
          
        case 'offer':
          appendLine(`üì• –ü–æ–ª—É—á–µ–Ω offer –æ—Ç ${data.from}`, {type: 'plain'});
          if (!peerConnection) {
            pendingOffer = data.offer;
          } else {
            await handleOffer(data.offer, data.from);
          }
          break;
          
        case 'answer':
          appendLine(`üì• –ü–æ–ª—É—á–µ–Ω answer –æ—Ç ${data.from}`, {type: 'plain'});
          await handleAnswer(data.answer);
          break;
          
        case 'ice-candidate':
          if (data.candidate) {
            if (!peerConnection) {
              pendingCandidates.push(data.candidate);
            } else {
              await handleIceCandidate(data.candidate);
            }
          }
          break;
          
        case 'call_declined':
          appendLine(`‚ùå –ó–≤–æ–Ω–æ–∫ –æ—Ç–∫–ª–æ–Ω–µ–Ω: ${data.from}`, {type: 'error', typing: true});
          cleanup();
          break;
          
        case 'call_ended':
          appendLine(`üìµ –ó–≤–æ–Ω–æ–∫ –∑–∞–≤–µ—Ä—à–µ–Ω: ${data.from}`, {type: 'plain', typing: true});
          cleanup();
          closeVideoModal();
          break;
          
        case 'error':
          appendLine(`‚ùå –û—à–∏–±–∫–∞: ${data.message}`, {type: 'error', typing: true});
          break;
      }
    }

    async function makeCall(targetName, callType = 'video') {
      if (!username || !ws || ws.readyState !== WebSocket.OPEN) {
        appendLine('‚ùå –°–Ω–∞—á–∞–ª–∞ –∞–≤—Ç–æ—Ä–∏–∑—É–π—Ç–µ—Å—å –∫–æ–º–∞–Ω–¥–æ–π: login –∏–º—è', {type: 'error', typing: true});
        return;
      }

      try {
        remoteUser = targetName;
        currentCallType = callType;
        isInitiator = true;

        const constraints = {
          audio: true,
          video: callType === 'video'
        };
        
        localStream = await navigator.mediaDevices.getUserMedia(constraints);
        document.getElementById('localVideo').srcObject = localStream;
        
        createPeerConnection();
        
        localStream.getTracks().forEach(track => {
          peerConnection.addTrack(track, localStream);
        });

        ws.send(JSON.stringify({
          type: 'call',
          target: targetName,
          callType: callType
        }));

        const offer = await peerConnection.createOffer();
        await peerConnection.setLocalDescription(offer);
        
        ws.send(JSON.stringify({
          type: 'offer',
          target: targetName,
          offer: offer
        }));

        appendLine(`üìû –ó–≤–æ–Ω–∏–º ${targetName}...`, {type: 'plain', typing: true});
        showNotification('–ó–≤–æ–Ω–æ–∫', `–ó–≤–æ–Ω–∏–º ${targetName}...`, 'info');
        showVideoModal();
        beep('success');
        
      } catch (error) {
        appendLine(`‚ùå –û—à–∏–±–∫–∞ –∑–≤–æ–Ω–∫–∞: ${error.message}`, {type: 'error', typing: true});
        beep('error');
      }
    }

    window.acceptCallFromNotification = async function() {
      await acceptCall();
    };

    window.declineCallFromNotification = async function() {
      await declineCall();
    };

    async function acceptCall() {
      try {
        appendLine('‚úÖ –ü—Ä–∏–Ω–∏–º–∞–µ–º –∑–≤–æ–Ω–æ–∫...', {type: 'result', typing: true});
        if (currentNotificationId) {
          currentNotificationId.classList.add('exit');
          setTimeout(() => currentNotificationId.remove(), 300);
        }

        const constraints = {
          audio: true,
          video: currentCallType === 'video'
        };
        
        localStream = await navigator.mediaDevices.getUserMedia(constraints);
        document.getElementById('localVideo').srcObject = localStream;
        
        createPeerConnection();
        
        localStream.getTracks().forEach(track => {
          peerConnection.addTrack(track, localStream);
        });

        if (pendingOffer) {
          await handleOffer(pendingOffer, remoteUser);
          pendingOffer = null;
        }

        if (pendingCandidates.length > 0) {
          for (const candidate of pendingCandidates) {
            await handleIceCandidate(candidate);
          }
          pendingCandidates = [];
        }

        showVideoModal();
        
      } catch (error) {
        appendLine(`‚ùå –û—à–∏–±–∫–∞: ${error.message}`, {type: 'error', typing: true});
      }
    }

    async function declineCall() {
      try {
        ws.send(JSON.stringify({
          type: 'decline',
          target: remoteUser
        }));
        if (currentNotificationId) {
          currentNotificationId.classList.add('exit');
          setTimeout(() => currentNotificationId.remove(), 300);
        }
        appendLine('‚ùå –ó–≤–æ–Ω–æ–∫ –æ—Ç–∫–ª–æ–Ω–µ–Ω', {type: 'plain', typing: true});
        remoteUser = null;
        pendingOffer = null;
        pendingCandidates = [];
      } catch (error) {
        appendLine(`‚ùå –û—à–∏–±–∫–∞: ${error.message}`, {type: 'error', typing: true});
      }
    }

    window.endCall = async function() {
      try {
        if (remoteUser && ws && ws.readyState === WebSocket.OPEN) {
          ws.send(JSON.stringify({
            type: 'end_call',
            target: remoteUser
          }));
        }
        cleanup();
        closeVideoModal();
      } catch (error) {
        appendLine(`‚ùå –û—à–∏–±–∫–∞: ${error.message}`, {type: 'error', typing: true});
      }
    };

    function createPeerConnection() {
      peerConnection = new RTCPeerConnection(iceServers);

      peerConnection.onicecandidate = (event) => {
        if (event.candidate && ws && ws.readyState === WebSocket.OPEN) {
          ws.send(JSON.stringify({
            type: 'ice-candidate',
            target: remoteUser,
            candidate: event.candidate
          }));
        }
      };

      peerConnection.ontrack = (event) => {
        appendLine('üì∫ –ü–æ–ª—É—á–µ–Ω —É–¥–∞–ª–µ–Ω–Ω—ã–π –ø–æ—Ç–æ–∫', {type: 'result'});
        document.getElementById('remoteVideo').srcObject = event.streams[0];
      };

      peerConnection.onconnectionstatechange = () => {
        appendLine(`üîó –°–æ—Å—Ç–æ—è–Ω–∏–µ: ${peerConnection.connectionState}`, {type: 'plain'});
        if (peerConnection.connectionState === 'disconnected' || 
            peerConnection.connectionState === 'failed') {
          cleanup();
          closeVideoModal();
        }
      };
    }

    async function handleOffer(offer, from) {
      try {
        await peerConnection.setRemoteDescription(new RTCSessionDescription(offer));
        
        const answer = await peerConnection.createAnswer();
        await peerConnection.setLocalDescription(answer);
        
        ws.send(JSON.stringify({
          type: 'answer',
          target: from,
          answer: answer
        }));
        
        appendLine('üì§ Answer –æ—Ç–ø—Ä–∞–≤–ª–µ–Ω', {type: 'result'});
        
      } catch (error) {
        appendLine(`‚ùå –û—à–∏–±–∫–∞ offer: ${error.message}`, {type: 'error'});
      }
    }

    async function handleAnswer(answer) {
      try {
        await peerConnection.setRemoteDescription(new RTCSessionDescription(answer));
        appendLine('‚úÖ Remote description —É—Å—Ç–∞–Ω–æ–≤–ª–µ–Ω', {type: 'result'});
      } catch (error) {
        appendLine(`‚ùå –û—à–∏–±–∫–∞ answer: ${error.message}`, {type: 'error'});
      }
    }

    async function handleIceCandidate(candidate) {
      try {
        if (peerConnection && peerConnection.remoteDescription) {
          await peerConnection.addIceCandidate(new RTCIceCandidate(candidate));
        }
      } catch (error) {
        console.error('Error adding ICE candidate:', error);
      }
    }

    function cleanup() {
      if (localStream) {
        localStream.getTracks().forEach(track => track.stop());
        localStream = null;
      }
      if (peerConnection) {
        peerConnection.close();
        peerConnection = null;
      }
      document.getElementById('localVideo').srcObject = null;
      document.getElementById('remoteVideo').srcObject = null;
      stopCallTimer();
      remoteUser = null;
      currentCallType = null;
      isInitiator = false;
      pendingOffer = null;
      pendingCandidates = [];
    }

    // Modal Dragging
    let isDragging = false;
    let dragOffsetX = 0;
    let dragOffsetY = 0;

    document.getElementById('modalHeader').addEventListener('mousedown', dragStart);
    document.addEventListener('mousemove', drag);
    document.addEventListener('mouseup', dragEnd);

    function dragStart(e) {
      const modal = document.getElementById('webrtcModal');
      const rect = modal.getBoundingClientRect();
      dragOffsetX = e.clientX - rect.left;
      dragOffsetY = e.clientY - rect.top;
      isDragging = true;
      e.preventDefault();
    }

    function drag(e) {
      if (isDragging) {
        e.preventDefault();
        const modal = document.getElementById('webrtcModal');
        const newLeft = e.clientX - dragOffsetX;
        const newTop = e.clientY - dragOffsetY;
        
        modal.style.right = 'auto';
        modal.style.left = newLeft + 'px';
        modal.style.top = newTop + 'px';
      }
    }

    function dragEnd() {
      isDragging = false;
    }

    function showVideoModal() {
      const modal = document.getElementById('webrtcModal');
      const videoContainer = document.getElementById('videoContainer');
      const audioIndicator = document.getElementById('audioCallIndicator');
      
      // Reset position to top-right
      modal.style.left = 'auto';
      modal.style.right = '24px';
      modal.style.top = '80px';
      
      // Show/hide video or audio indicator
      if (currentCallType === 'video') {
        videoContainer.style.display = 'block';
        audioIndicator.style.display = 'none';
      } else {
        videoContainer.style.display = 'none';
        audioIndicator.style.display = 'block';
      }
      
      modal.classList.add('active');
      startCallTimer();
    }

    window.closeVideoModal = function() {
      document.getElementById('webrtcModal').classList.remove('active');
      endCall();
    };

    // Command Processing
    async function sendCommand(cmdText) {
      if(!cmdText || !cmdText.trim()) return;
      
      const trimmed = cmdText.trim();
      const parts = trimmed.split(/\s+/);
      const cmd = parts[0].toLowerCase();

      // WebRTC Commands
      if (cmd === 'login' || cmd === '–≤–æ–π—Ç–∏') {
        const name = parts[1];
        if (!name) {
          appendLine('‚ùå –£–∫–∞–∂–∏—Ç–µ –∏–º—è: login –∏–º—è', {type: 'error', typing: true});
          return;
        }
        appendLine(`> ${cmdText}`, {typing: true});
        await webrtcLogin(name);
        input.value = '';
        return;
      }

      if (cmd === '–ø–æ–∑–≤–æ–Ω–∏—Ç—å' || cmd === 'call') {
        const targetName = parts[1];
        const callType = parts[2] || 'video';
        if (!targetName) {
          appendLine('‚ùå –£–∫–∞–∂–∏—Ç–µ –∏–º—è: –ø–æ–∑–≤–æ–Ω–∏—Ç—å –∏–º—è video/audio', {type: 'error', typing: true});
          return;
        }
        appendLine(`> ${cmdText}`, {typing: true});
        await makeCall(targetName, callType);
        input.value = '';
        return;
      }

      // Regular calculator commands
      appendLine(`> ${cmdText}`, {typing: true});
      input.value = '';
      
      try {
        const res = await fetch('/api/execute', {
          method: 'POST',
          headers: {'Content-Type': 'application/json'},
          body: JSON.stringify({input: cmdText})
        });
        const data = await res.json();
        if(data.error) {
          appendLine(data.error, {type: 'error', typing: true});
          beep('error');
        } else {
          appendLine(JSON.stringify(data.result, null, 2), {type: 'result', typing: true});
          beep('success');
        }
      } catch(e) {
        appendLine('–û—à–∏–±–∫–∞ —Å–µ—Ç–∏: ' + String(e), {type: 'error', typing: true});
        beep('error');
      }
    }

    form.addEventListener('submit', (ev) => {
      ev.preventDefault();
      sendCommand(input.value);
    });

    document.addEventListener('keydown', (ev) => {
      if((ev.ctrlKey || ev.metaKey) && ev.key.toLowerCase() === 'k') {
        ev.preventDefault();
        input.focus();
        input.select();
      }
      if(ev.key === 'Escape') {
        hideCards();
      }
    });

    btnVars.addEventListener('click', async () => {
      try {
        const r = await fetch('/api/vars');
        const vars = await r.json();
        appendLine('–ü–µ—Ä–µ–º–µ–Ω–Ω—ã–µ:', {type: 'plain'});
        appendLine(JSON.stringify(vars, null, 2), {type: 'result', typing: true});
      } catch(e) {
        appendLine('–û—à–∏–±–∫–∞ –∑–∞–≥—Ä—É–∑–∫–∏ –ø–µ—Ä–µ–º–µ–Ω–Ω—ã—Ö: ' + String(e), {type: 'error', typing: true});
      }
    });

    btnHistory.addEventListener('click', async () => {
      try {
        const r = await fetch('/api/history');
        const hist = await r.json();
        showCards(hist || []);
      } catch(e) {
        appendLine('–û—à–∏–±–∫–∞ –∑–∞–≥—Ä—É–∑–∫–∏ –∏—Å—Ç–æ—Ä–∏–∏: ' + String(e), {type: 'error', typing: true});
      }
    });

    btnClear.addEventListener('click', clearOutput);

    function showCards(items) {
      cardsInner.innerHTML = '';
      if(!Array.isArray(items) || items.length === 0) {
        const no = document.createElement('div');
        no.className = 'card';
        no.innerHTML = `<div class="meta">–ò—Å—Ç–æ—Ä–∏—è</div><div class="body">–ü—É—Å—Ç–æ</div>`;
        cardsInner.appendChild(no);
      } else {
        items.slice().reverse().forEach(cmd => {
          const card = document.createElement('div');
          card.className = 'card';
          const meta = document.createElement('div');
          meta.className = 'meta';
          meta.textContent = `–ö–æ–º–∞–Ω–¥–∞ ‚Ä¢ ${new Date().toLocaleString()}`;
          const body = document.createElement('div');
          body.className = 'body';
          body.textContent = String(cmd);
          card.appendChild(meta);
          card.appendChild(body);
          card.addEventListener('click', () => {
            input.value = cmd;
            input.focus();
            card.animate([{transform:'scale(1)'}, {transform:'scale(.995)'}], {duration:150, easing:'ease-out'});
          });
          cardsInner.appendChild(card);
        });
      }
      cards.classList.remove('hidden');
      cards.setAttribute('aria-hidden', 'false');
    }

    function hideCards() {
      cards.classList.add('hidden');
      cards.setAttribute('aria-hidden', 'true');
    }

    closeCards.addEventListener('click', hideCards);
    document.addEventListener('click', (ev) => {
      if(!cards.classList.contains('hidden')) {
        const inside = cards.contains(ev.target) || ev.target === btnHistory;
        if(!inside) hideCards();
      }
    });

    clearOutput();
  </script>
</body>
</html>